The whold file system occupied 512 blocks each 512 bytes. The first two blocks was occupied. Blocks from 2 to 17 (16 total) are used as the index blocks. The remaining blocks are used as the data blocks.

fs_creat: To create a file, we need to find the next available file number and return it. Before returning the file number, we need to initialize the filetable, the filesystem and the inode.
By the file number, we first access the filetable in the filetable array defined as oft. Set the state to be FSTATE_OPEN and the fileptr to be 0. Then we connect the filetable.de with the root_dir in the filesystem defined as fsd and then set the filename and the inode number. At last, set the filetable.in inode and write the information onto the proper block using fs_put_inode_by_num.

fs_open: Opening a file means setting the state in filetable as FSTATE_OPEN. So we find the proper file using its name to find it in the root_dir to get the file number. Set the file state.

fs_write: To write a file, we need the help of function bs_bwrite. We first decide how many blocks we need an how much to write on each block. Then we call the function bs_bwrite to write on each block with proper offset and proper lenght (in our case, the whole block is 512 bytes).

fs_read: Reading is a lot like writing a file. By the information of the file pointer and the reading bytes, we decide how many blocks to read and the lenght of each blocks. Then  we call the function bs_bread to read the information of each block into the buffer. After both the operation of reading and writing, we need to adjust the file pointer to the proper position.

fs_seek: Seeking is an operation to rest the position of a file pointer. After checking all the input to be legal, we set the pointer by the amount of the offset.

fs_close: File close is relatively simple. We only need to set the state in filetable to be FSTATE_CLOSED. We will leave the user to write the modified contents into the data blocks before closing the file.

The filesystem we implemented is a really a simple one. We did not consider the secondary disk to store the data, did not implement a function to easily modify the contests of a file (even though we can do it by seek and write) and did not implement the deleting operation.
But this assignment reveals the key components of a proper filesystem: the necessary structure to construct a filesystem, the basic oprations on the files and the hand-on practice to implement one.
After this assignment, I now know much better about the strucutre of a filesystem. I am now able to implement more complex features of an advanced filesystem.
